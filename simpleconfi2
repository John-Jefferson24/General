## SIMPLIFIED MODEL PROXY CONFIGURATION (SINGLE MODEL) ##

# Load only necessary modules
LoadModule proxy_module modules/mod_proxy.so
LoadModule proxy_http_module modules/mod_proxy_http.so
LoadModule security2_module modules/mod_security2.so
LoadModule headers_module modules/mod_headers.so
LoadModule rewrite_module modules/mod_rewrite.so

# Logging
LogLevel warn
ErrorLog /var/log/httpd/proxy_error.log
CustomLog /var/log/httpd/proxy_access.log combined

# Global proxy settings
ProxyRequests Off
ProxyPreserveHost On

# Enable ModSecurity to parse JSON and extract the model name
<IfModule mod_security2.c>
    SecRuleEngine On
    SecRequestBodyAccess On
    
    # Increased request body limits for large model inputs
    SecRequestBodyLimit 209715200
    SecRequestBodyLimitAction ProcessPartial
    
    # Enable JSON parsing
    SecRule REQUEST_HEADERS:Content-Type "application/json" \
           "id:1000,phase:1,pass,ctl:requestBodyProcessor=JSON"
    
    # Extract model name - use a simple SecRule that works
    SecRule REQUEST_BODY:model ".*" \
           "id:2000,phase:2,capture,pass,setenv:model=%{TX.0}"
</IfModule>

# Enable URL rewriting for environment-based path modification
RewriteEngine On

# Single model routing example
RewriteCond %{ENV:model} ^gpt-model-1$ [NC]
RewriteRule ^(.*)$ /model1$1 [PT,L]

# ProxyPass directive for the model path
ProxyPass "/model1" "http://triton1.internal/v1/chat/completions"

# Default fallback - this is crucial
ProxyPass "/" "http://triton1.internal/v1/chat/completions"

# CORS headers for API compatibility
Header always set Access-Control-Allow-Origin "*"
Header always set Access-Control-Allow-Headers "Content-Type, Authorization"
Header always set Access-Control-Allow-Methods "POST, GET, OPTIONS"
Header always set Cache-Control "no-store"

# Debug header to confirm which model was requested
Header always set X-Debug-Model "%{model}e" env=model
