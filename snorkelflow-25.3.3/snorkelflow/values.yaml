# The project name is also the name of the Kubernetes namespace
projectName: snorkelflow
version: 25.3.3
image:
  # Configure a registry to use for snorkelflow images. If images are specified under imageNames.{component}, then registry
  # will be ignored for that component's image.
  # registry: ""
  # Configure an imagePullSecret
  # imagePullSecret: regcred
  # Configure custom image names for each service running with
  # Snorkel Flow.
  imageNames: {}
    # clickhouse: "snorkelai/clickhouse:snorkelai/clickhouse:25.3.2.39a"
    # postgres: "snorkelai/postgres:16.8a"
    # prometheus: "snorkelai/prometheus:snorkelai/prometheus:3.3.0a"
    # engine: "snorkelai/engine:25.3.3"
    # envoy: "snorkelai/envoy:v1.33.2a"
    # flowUi: "snorkelai/flow-ui:25.3.3"
    # grafana: "snorkelai/grafana:11.6.0a"
    # influxdb: "snorkelai/influxdb:2.7.11d"
    # jupyterhub: "snorkelai/jupyterhub:4.0.0g"
    # jupyterhubProxy: "snorkelai/jupyterhub-proxy:4.6.3c"
    # minio: "snorkelai/minio:RELEASE.2022-05-26T05-48-41Zm"
    # notebook: "snorkelai/notebook:25.3.3"
    # redis: "snorkelai/redis:7.2.7b"
    # secretsGenerator: "snorkelai/secrets-generator:25.3.3"
    # singleuserNotebook: "snorkelai/singleuser-notebook"
    # studio: "snorkelai/studio-api:25.3.3"
    # telegraf: "snorkelai/telegraf:1.29.5l"
    # tdm: "snorkelai/tdm-api:25.3.3"
    # authorization: "snorkelai/authorization-api:25.3.3"
    # pretrainedModelImage: "snorkelai/pretrained-model-image:v0.1.3"
    # storage: "snorkelai/storage-api:25.3.3"
    # vector: "snorkelai/vector:snorkelai/vector:0.46.0a"
# Add a pagerduty key here to setup a notifier for Grafana to PagerDuty
pagerduty_key: PAGERDUTY_KEY
affinity:
  # set to true to specify affinity in deployments for bin-packing purposes
  binPackAlwaysPinnedPods: false
  # Set node selectors for all pods aside from gpu pods (configured separately in gpu.gpu_config)
  # nodeSelectors:
  #   key: value
  # Set tolerations for all pods aside from gpu pods (configured separately in gpu.gpu_config)
  # tolerations:
  # - effect: NoSchedule
  #   key: snorkel
  #   operator: Equal
  #   value: worker
  # Set node affinity rules for all pods aside from gpu pods
  # nodeAffinity:
  #   requiredDuringSchedulingIgnoredDuringExecution:
  #     nodeSelectorTerms:
  #     - matchExpressions:
  #       - key: snorkel
  #         operator: In
  #         values:
  #         - worker
autoscaling:
  # set to "1" to turn on up/down autoscaling for workers pods (engine, model-trainer, ray-worker)
  worker_autoscaling: "0"  # replica floor and limits for pod autoscaling are defined in services.SERVICE.max_replicas/min_replicas
  cluster_autoscaling:
    # set to "1" to turn on toggling for pod disruption budgets for non-worker pods (i.e. allow those pods to be moved on/off nodes during non-business hours for cluster autoscaling purposes)
    pod_disruption_budget_toggling: "0"
    business_hour_start_utc: 11
    business_hour_end_utc: 4
traffic:
  # Set this flag to enable Snorkel Flow under a given base path
  # basePath: "/snorkel"
  istio:
    enabled: false
    mtls:
      enabled: false
    gateway:
      create: true
      # Used to specify existing gateway when create is false
      # name: snorkelflow-gateway
      # namespace: snorkelflow
  # Configure urls and domain. Snorkel Flow urls will be {urls.service}.{domain}
  # e.g. snorkelflow.snorkel-ai.com
  ingresses:
    domain: snorkel-ai.com
    ingressClassName: null
    # The ServiceType for services that require an ingress (e.g. ClusterIP, NodePort)
    # https://kubernetes.io/docs/concepts/services-networking/service/
    serviceType: ClusterIP
    # Specify the cloud provider the ingresses are for or leave blank otherwise.
    # Currently supported providers: gcp
    # cloudProvider: gcp
    # By default, do not generate tls hosts for ingresses
    tlsHosts:
      enabled: false
      tlsSecretName: null
    annotations: {}
    # global annotations that apply to all service ingresses
    services:
      influxdb:
        enabled: true
        urlPrefix: snorkelflow-influxdb
        annotations: {}
        # Key and values of any additional annotations needed per service
        # e.g. nginx.org/proxy-connect-timeout: "30s"
      minio:
        enabled: true
        urlPrefix: snorkelflow-minio
        annotations: {}
      minioApi:
        enabled: true
        urlPrefix: snorkelflow-minio-api
        annotations: {}
      snorkelflow:
        enabled: true
        urlPrefix: snorkelflow
        annotations: {}
      studio:
        enabled: true
        urlPrefix: snorkelflow-studio-api
        annotations: {}
      tdm:
        enabled: true
        urlPrefix: snorkelflow-tdm-api
        annotations: {}
      storage:
        enabled: true
        urlPrefix: snorkelflow-storage-api
        annotations: {}
  tls:
    # Names of Kubernetes secrets that contain a single file each for use by Envoy
    # to terminate TLS. These secrets must be present for Snorkel Flow to operate.
    # See envoy-front-proxy-envoy-front-proxy-json-config-map.yaml for references.
    key_secret_name: envoy-front-proxy-envoy-tls-key-pem-secret
    cert_secret_name: envoy-front-proxy-envoy-tls-cert-pem-secret
  # By default, permit selected services to receive all inbound traffic.
  # You may disable this option and use the `networkPolicies.ingresses` block below to limit access
  allowAllInboundTrafficOnKeyServices: true
  # By default, allow pods to connect to the internet.
  allowInternetAccess: true
  networkPolicies:
    enabled: false
    ingresses: []
    # List of `from` blocks which map to ingresses for key Snorkel Flow services
    # - from:
    #   - podSelector:
    #       matchLabels:
    #         special: ingress
gpu:
  # Enable GPU support
  enabled: false
  separate_gpu_pods: false
  gpu_config: {}
    # gpu_config configures specific GPU-related taints and/or node selectors
    # tolerations:
    #   - effect: NoSchedule
    #     key: GPU
    #     operator: Equal
    #     value: "true"
    # node_selectors:
    #   GPU: "true"
    # Configure a GPU scheduler (e.g. if using Run:ai)
    # schedulerName: "runai-scheduler"

# Defines whether to use arrow backed key value disk cache
optimizations:
  arrow_cache:
    enabled: true

# Defines whether to use prefect in some components of the system
prefect:
  enabled: true

namespace:
  # Include namespace creation
  enabled: true
services:
  # Defines environment variables that apply to all deployments
  env: {
    # Set to '1' to enable logging all audit events to stdout. Disabled by default or set to '0'.
    # AUDIT_EVENTS_TO_STDOUT_ENABLED: '1'
  }
  # Defines kubernetes labels that apply to all deployments
  labels: {}
  clickhouse:
    # Define non-default resource limits & requests
    resources: {}
    env: {}
    labels: {}
  db:
    # Define non-default resource limits & requests
    resources: {}
    shared_buffers: 2GB  # this should ideally be 25% of the requested db memory
    env: {}
    labels: {}
    # sensitive env vars will be set by passing filename instead of k8s SecretKeySelector
    secretsFromFile: false
  engine:
    # Define non-default resource limits & requests
    resources: {}
    min_replicas: 0  # this is the replica floor, the actual replica count is set to 0 when templating if pod_autoscaling is turned on
    max_replicas: 1  # this is the replica limit, the actual replica count is set to 0 when templating if pod_autoscaling is turned on
    env: {}
    labels: {}
    # sensitive env vars will be set by passing filename instead of k8s SecretKeySelector
    secretsFromFile: false
  engineTiny:
    # Define non-default resource limits & requests
    resources: {}
    env: {}
    labels: {}
    # sensitive env vars will be set by passing filename instead of k8s SecretKeySelector
    secretsFromFile: false
  envoyFrontProxy:
    # Define non-default resource limits & requests
    resources: {}
    env: {}
    labels: {}
  flowUi:
    # Define non-default resource limits & requests
    resources: {}
    env: {}
    labels: {}
    # sensitive env vars will be set by passing filename instead of k8s SecretKeySelector
    secretsFromFile: false
  grafana:
    # Define non-default resource limits & requests
    resources: {}
    env: {}
    labels: {}
    # sensitive env vars will be set by passing filename instead of k8s SecretKeySelector
    secretsFromFile: false
  influxdb:
    # Define non-default resource limits & requests
    resources: {}
    env: {}
    labels: {}
  jupyterhub:
    # Define non-default resource limits & requests
    resources: {}
    env: {}
    labels: {}
    # sensitive env vars will be set by passing filename instead of k8s SecretKeySelector
    secretsFromFile: false
    # Enable the in-platform notebook
    enabled: true
    singleUserNotebook:
      # The name of the service account to bind to the single-user notebook pods
      serviceAccountName: snorkelflow-jupyterhub-user-sa
      # The start timeout of a single-user notebook pod, in seconds
      startTimeout: 300
      # Whether notebook pods should spin up with a GPU (gpu.gpu_config must be filled out)
      gpu: false
      # Whether to limit its minio access to its own user directory
      minio_user_dir_only: false
      # Defines the resources given to each user's notebook
      resources:
        cpu_guarantee: 1
        cpu_limit: 1
        memory_guarantee: 2G
        memory_limit: 8G
      storage:
        # The storage class to use for the persistent volume bound to the single-user notebook pod
        # Used when storage type is dynamic
        dynamicClass: "null"
        # The storage type to use (static/dynamic)
        type: dynamic
  jupyterhubProxy:
    # Define non-default resource limits & requests
    resources: {}
    env: {}
    labels: {}
    # sensitive env vars will be set by passing filename instead of k8s SecretKeySelector
    secretsFromFile: false
  minio:
    ui:
      enabled: true # enable/disable minioUI
    # Define non-default resource limits & requests
    resources: {}
    env: {}
    labels: {}
    auth:
      username: snorkeladmin
      password: snorkeladmin
  modelTrainer:
    # Define non-default resource limits & requests
    resources: {}
    min_replicas: 0  # this is the replica floor, the actual replica count is set to 0 when templating if pod_autoscaling is turned on
    max_replicas: 1  # this is the replica limit, the actual replica count is set to 0 when templating if pod_autoscaling is turned on
    env: {}
    labels: {}
    # sensitive env vars will be set by passing filename instead of k8s SecretKeySelector
    secretsFromFile: false
  notebook:
    # Define non-default resource limits & requests
    resources: {}
    env: {}
    labels: {}
    # sensitive env vars will be set by passing filename instead of k8s SecretKeySelector
    secretsFromFile: false
  prometheus:
    # Define non-default resource limits & requests
    resources: {}
    env: {}
    labels: {}
  rayHead:
    # Define non-default resource limits & requests
    resources: {}
    env: {}
    labels: {}
    # sensitive env vars will be set by passing filename instead of k8s SecretKeySelector
    secretsFromFile: false
  rayGpuWorker:
    # Define non-default resource limits & requests
    resources: {}
    env: {}
    labels: {}
    min_replicas: 0  # this is the replica floor, the actual replica count is set to 0 when templating if pod_autoscaling is turned on
    max_replicas: 0  # this is the replica limit, the actual replica count is set to 0 when templating if pod_autoscaling is turned on
    # sensitive env vars will be set by passing filename instead of k8s SecretKeySelector
    secretsFromFile: false
  rayWorker:
    # Define non-default resource limits & requests
    resources: {}
    env: {}
    labels: {}
    min_replicas: 0  # this is the replica floor, the actual replica count is set to 0 when templating if pod_autoscaling is turned on
    max_replicas: 2  # this is the replica limit, the actual replica count is set to 0 when templating if pod_autoscaling is turned on
    # sensitive env vars will be set by passing filename instead of k8s SecretKeySelector
    secretsFromFile: false
  redis:
    # Define non-default resource limits & requests
    resources: {}
    env: {}
    labels: {}
  secretsGenerator:
    # Enable the secrets generator job
    enabled: false
  studioApi:
    # Define non-default resource limits & requests
    resources: {}
    env: {}
    labels: {}
    # sensitive env vars will be set by passing filename instead of k8s SecretKeySelector
    secretsFromFile: false
  studioRayHead:
    # Define non-default resource limits & requests
    resources: {}
    env: {}
    labels: {}
    # sensitive env vars will be set by passing filename instead of k8s SecretKeySelector
    secretsFromFile: false
  studioRayWorker:
    # Define non-default resource limits & requests
    resources: {}
    env: {}
    labels: {}
    # sensitive env vars will be set by passing filename instead of k8s SecretKeySelector
    secretsFromFile: false
    # Configure the number of replicas for the studio-ray-worker deployment
    # replicas: 1
  tdmApi:
    # Define non-default resource limits & requests
    resources: {}
    env: {}
    labels: {}
    # sensitive env vars will be set by passing filename instead of k8s SecretKeySelector
    secretsFromFile: false
  telegraf:
    # Define non-default resource limits & requests
    resources: {}
    env: {}
    labels: {}
    # sensitive env vars will be set by passing filename instead of k8s SecretKeySelector
    secretsFromFile: false
  authorizationApi:
    # Define non-default resource limits & requests
    resources: {}
    env: {}
    labels: {}
    # sensitive env vars will be set by passing filename instead of k8s SecretKeySelector
    secretsFromFile: false
  storageApi:
    # Define non-default resource limits & requests
    resources: {}
    env: {}
    labels: {}
    # sensitive env vars will be set by passing filename instead of k8s SecretKeySelector
    secretsFromFile: false
  vector:
    # Define non-default resource limits & requests
    resources: {}
    env: {}
    labels: {}
volumes:
  snorkelflowData:
    # whether the data volume is using SMB underneath
    smb: false
    # Configure the storageclass for the ReadWriteMany volume, which is typically a
    # NFS volume.
    storageClass: "aws-efs"
    storageRequest: 50Gi
    # Configure the volumeName for the ReadWriteMany volume if using a specific volume.
    # If creation of the PersistentVolume is enabled, this volumeName will not be used.
    # volumeName: "snorkelflow-data-volume"
    persistentVolume:
      # Enable creation of the PersistentVolume associated with the PersistentVolumeClaim
      enabled: false
      driver: {}
        # Spec for the driver of the PersistentVolume. We expect this to be a driver that is
        # compatible with the ReadWriteMany access mode, e.g an NFS driver.
        # csi:
        #   driver: efs.csi.aws.com
        #   volumeAttributes:
        #     encryptInTransit: "true"
        #   volumeHandle: fs-49874590::fsap-349874597490
    # Configure the persistentVolumeClaim name used for snorkelflow data.
    persistentVolumeClaimName: null
  clickhouse:
    # Configure the storageclass for the ReadWriteOnce volume, which defaults to using the default storageclass
    # storageClass: "aws-efs"
    storageRequest: 25Gi
    # Configure the volumeName for the ReadWriteOnce volume if using a specific volume.
    # If creation of the PersistentVolume is enabled, this volumeName will not be used.
    # volumeName: "snorkelflow-clickhouse-volume"
    persistentVolume:
      # Enable creation of the PersistentVolume associated with the PersistentVolumeClaim
      enabled: false
      driver: {}
        # Spec for the driver of the PersistentVolume.
        # csi:
        #   driver: efs.csi.aws.com
        #   volumeAttributes:
        #     encryptInTransit: "true"
        #   volumeHandle: fs-49874590::fsap-349874597490
  influxdb:
    # Configure the storageclass for the ReadWriteOnce volume, which defaults to using the default storageclass
    # storageClass: "aws-efs"
    storageRequest: 10Gi
    # Configure the volumeName for the ReadWriteOnce volume if using a specific volume.
    # If creation of the PersistentVolume is enabled, this volumeName will not be used.
    # volumeName: "snorkelflow-influxdb-volume"
    persistentVolume:
      # Enable creation of the PersistentVolume associated with the PersistentVolumeClaim
      enabled: false
      driver: {}
        # Spec for the driver of the PersistentVolume.
        # csi:
        #   driver: efs.csi.aws.com
        #   volumeAttributes:
        #     encryptInTransit: "true"
        #   volumeHandle: fs-49874590::fsap-349874597490
  postgres:
    # Configure the storageclass for the ReadWriteOnce volume, which defaults to using the default storageclass
    # storageClass: "aws-efs"
    storageRequest: 10Gi
    # Configure the volumeName for the ReadWriteOnce volume if using a specific volume.
    # If creation of the PersistentVolume is enabled, this volumeName will not be used.
    # volumeName: "snorkelflow-postgres-volume"
    persistentVolume:
      # Enable creation of the PersistentVolume associated with the PersistentVolumeClaim
      enabled: false
      driver: {}
        # Spec for the driver of the PersistentVolume.
        # csi:
        #   driver: efs.csi.aws.com
        #   volumeAttributes:
        #     encryptInTransit: "true"
        #   volumeHandle: fs-49874590::fsap-349874597490
  prometheus:
    # Configure the storageclass for the ReadWriteOnce volume, which defaults to using the default storageclass
    # storageClass: "aws-efs"
    storageRequest: 10Gi
    # Configure the volumeName for the ReadWriteOnce volume if using a specific volume.
    # If creation of the PersistentVolume is enabled, this volumeName will not be used.
    # volumeName: "snorkelflow-prometheus-volume"
    persistentVolume:
      # Enable creation of the PersistentVolume associated with the PersistentVolumeClaim
      enabled: false
      driver: {}
        # Spec for the driver of the PersistentVolume.
        # csi:
        #   driver: efs.csi.aws.com
        #   volumeAttributes:
        #     encryptInTransit: "true"
        #   volumeHandle: fs-49874590::fsap-349874597490
  redis:
    # Configure the storageclass for the ReadWriteOnce volume, which defaults to using the default storageclass
    # storageClass: "aws-efs"
    storageRequest: 10Gi
    # Configure the volumeName for the ReadWriteOnce volume if using a specific volume.
    # If creation of the PersistentVolume is enabled, this volumeName will not be used.
    # volumeName: "snorkelflow-redis-volume"
    persistentVolume:
      # Enable creation of the PersistentVolume associated with the PersistentVolumeClaim
      enabled: false
      driver: {}
        # Spec for the driver of the PersistentVolume.
        # csi:
        #   driver: efs.csi.aws.com
        #   volumeAttributes:
        #     encryptInTransit: "true"
        #   volumeHandle: fs-49874590::fsap-349874597490
  jupyterhub:
    # Configure the storageclass for the ReadWriteOnce volume, which defaults to using the default storageclass
    # storageClass: "aws-efs"
    storageRequest: 2Gi
    # Configure the volumeName for the ReadWriteOnce volume if using a specific volume.
    # If creation of the PersistentVolume is enabled, this volumeName will not be used.
    # volumeName: "snorkelflow-jupyterhub-volume"
    persistentVolume:
      # Enable creation of the PersistentVolume associated with the PersistentVolumeClaim
      enabled: false
      driver: {}
        # Spec for the driver of the PersistentVolume.
        # csi:
        #   driver: efs.csi.aws.com
        #   volumeAttributes:
        #     encryptInTransit: "true"
        #   volumeHandle: fs-49874590::fsap-349874597490
authorization:
  adRoles:
    enabled: false
    # Get roles from OIDC /userinfo claim. Please consult Snorkel support before enabling.
    # If prefix is set, then roles should be in the form: {prefix}{separator}{workspace}{separator}{user_role}.
    # If prefix is not set, roles should be in the form: {workspace}{separator}{user_role}.
    oidc: {}
      # Claim in OIDC userinfo response to look for AD roles in
      # claim: "claim"
      # prefix: "prefix"
      # separator: "_"
    # Get roles from SAML attributes. Please consult Snorkel support before enabling.
    saml: {}
      # Attribute in <AttributeStatement> to look for AD roles in
      # attributeName: "SnorkelRoles"
      # prefix: "prefix"
      # separator: "_"
authentication:
  # Use external JWT to login, please consult Snorkel support before enabling
  jwt:
    enabled: false
    # deployment:
  oidc:
    # Configure OIDC parameters for SSO using configmap instead of using the UI
    enabled: false
    admissionRolesSettings: {}
      # admissionRoles: role1,role2,role3
      # admissionRolesScope: profile
      # admissionRolesClaim: rolesclaim
    oidcProviderSettings: {}
      # clientId:
      # clientSecret:
      # redirectUris:
      # issuer:
      # authorizationEndpoint:
      # tokenEndpoint:
      # userinfoEndpoint:
      # jwksUri:
      # userinfoHandler:
      # resourceId:
      # userinfoUid:
    ssoSettings: {}
      # ssoEnabled: "true"
      # ssoRequired: "false"
      # ssoType: OIDC
  # Define a role for deployments to use
  # key and value will be injected as an annotation on all service accounts created by this chart
  role:
    key: null
    value: null
observability:
  logging_stack: "HYBRID"
  exporters:
    datadog:
      enabled: false
    prometheus:
      enabled: true
pretrained_models:
  # Use model crate for local model loading, please consult Snorkel support before enabling
  enabled: false

influx_cloud_key: ""

featureFlag:
  launchDarklySdkKey:
    value: ""
    # user provided secret that contains the key launch_darkly_sdk_key. This will override
    # the value field if both are provided.
    secretRef: ""
  # endpoint for launch darkly relay proxy. Leave empty for launch darkly server
  launchDarklyRelayEndpoint: ""
  launchDarklyRelayIngressEndpoint: ""
  launchDarklyClientSideId:
    value: ""
    # user provided secret that contains the key launch_darkly_client_side_id. This will override
    # the value field if both are provided.
    secretRef: ""
