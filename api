import os
import json
import logging
import requests
from jwt import decode as jwt_decode, get_unverified_header, InvalidTokenError

# Configure logging with rotation
from logging.handlers import RotatingFileHandler
handler = RotatingFileHandler(
    os.getenv('LOG_FILE', '/var/log/api.log'),
    maxBytes=10*1024*1024,
    backupCount=5
)
logging.basicConfig(handlers=[handler], level=logging.INFO)

# Configuration
JWKS_URL = os.getenv('JWKS_URL', 'https://pingfederate.yourbank.com/.well-known/jwks.json')
AUDIENCE = os.getenv('AUDIENCE', 'your_client_id')
ISSUER = os.getenv('ISSUER', 'https://pingfederate.yourbank.com')
REDIRECT_URL = os.getenv('JWT_REDIRECT_URL', '/jwt-callback')

def validate_jwt(token):
    """Validate JWT using PingFederate's JWKS endpoint."""
    try:
        jwks = requests.get(JWKS_URL, timeout=5, verify=True).json()
        header = get_unverified_header(token)
        kid = header['kid']
        key = next(k for k in jwks['keys'] if k['kid'] == kid)
        decoded = jwt_decode(
            token,
            key,
            algorithms=['RS256'],
            audience=AUDIENCE,
            issuer=ISSUER
        )
        return decoded
    except (requests.RequestException, InvalidTokenError, KeyError, StopIteration) as e:
        logging.error(f"JWT validation failed: {str(e)}")
        return None

def error_response(message, status, headers, start_response):
    """Return a standardized error response."""
    logging.error(message)
    start_response(status, headers)
    return [json.dumps({
        "error": {
            "message": message,
            "type": "invalid_request_error",
            "param": None,
            "code": None
        }
    }).encode('utf-8')]

# ===== BEGIN TEST FUNCTIONALITY =====
# You can remove this entire function if you want to delete test functionality
def handle_test_request(environ, start_response):
    """Handle test requests without JWT validation."""
    logging.info("Handling test request - bypassing JWT validation")
    headers = [('Content-Type', 'application/json')]
    
    # Parse JSON body
    try:
        content_length = int(environ.get('CONTENT_LENGTH', 0))
        body = environ['wsgi.input'].read(content_length).decode('utf-8')
        data = json.loads(body) if body else {}
    except (ValueError, json.JSONDecodeError) as e:
        return error_response(f"Invalid JSON: {str(e)}", '400 Bad Request', headers, start_response)

    # Extract model name - works for both completions and embeddings
    model_name = data.get('model')
    if not model_name:
        return error_response("Missing model field", '400 Bad Request', headers, start_response)

    # Set MODEL_NAME for Apache routing
    os.environ['MODEL_NAME'] = model_name
    
    # Add header for Apache routing
    headers.append(('X-Original-Model', model_name))
    
    # Log test request
    logging.info(f"TEST MODE: Processed model: {model_name}")
    
    # Return standard response
    start_response('200 OK', headers)
    return [json.dumps({
        "status": "Request processed",
        "model": model_name,
        "message": "Forwarding to backend via Apache proxy"
    }).encode('utf-8')]
# ===== END TEST FUNCTIONALITY =====

def application(environ, start_response):
    """WSGI application for JSON processing and backend forwarding."""
    path_info = environ.get('PATH_INFO', '')
    
    # ===== BEGIN TEST ENDPOINT CHECK =====
    # Remove these lines if you want to delete test functionality
    if path_info == '/test' or environ.get('HTTP_X_TEST_MODE') == 'true':
        return handle_test_request(environ, start_response)
    # ===== END TEST ENDPOINT CHECK =====
    
    headers = [('Content-Type', 'application/json')]
    
    # Check JWT token from various possible sources
    jwt_token = None
    
    # Method 1: X-JWT-Token header (used by Python clients like OpenAI/LangChain)
    for key, value in environ.items():
        if key.startswith('HTTP_') and key[5:].lower() == 'x_jwt_token':
            jwt_token = value
            break
    
    # Method 2: Authorization header with Bearer token (common API pattern)
    if not jwt_token and 'HTTP_AUTHORIZATION' in environ:
        auth = environ['HTTP_AUTHORIZATION']
        if auth.startswith('Bearer '):
            jwt_token = auth[7:]  # Remove 'Bearer ' prefix
    
    # If no token found or invalid token - return 401 (no redirect)
    if not jwt_token or not validate_jwt(jwt_token):
        if not jwt_token:
            logging.error("Missing JWT token")
        else:
            logging.error("Invalid JWT token")
            
        # Return 401 with JSON error for API clients
        start_response('401 Unauthorized', headers)
        return [json.dumps({
            "error": {
                "message": "Authentication required. Please provide a valid JWT token.",
                "type": "authentication_error"
            }
        }).encode('utf-8')]
    
    # Parse JSON body - minimal validation
    try:
        content_length = int(environ.get('CONTENT_LENGTH', 0))
        body = environ['wsgi.input'].read(content_length).decode('utf-8')
        data = json.loads(body) if body else {}
    except (ValueError, json.JSONDecodeError) as e:
        return error_response(f"Invalid JSON: {str(e)}", '400 Bad Request', headers, start_response)

    # Extract model name - works for both completions and embeddings
    model_name = data.get('model')
    if not model_name:
        return error_response("Missing model field", '400 Bad Request', headers, start_response)

    # Set MODEL_NAME for Apache routing
    os.environ['MODEL_NAME'] = model_name
    
    # Add header for Apache routing
    headers.append(('X-Original-Model', model_name))
    
    logging.info(f"Processed model: {model_name}")

    # Return intermediate response - Apache will handle proxying to the actual model
    start_response('200 OK', headers)
    return [json.dumps({
        "status": "Request processed",
        "model": model_name,
        "message": "Forwarding to backend via Apache proxy"
    }).encode('utf-8')]

SetEnvIf X-Original-Model "(.+)" MODEL_NAME=$1

