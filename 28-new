httpd.conf

# =========================================================
# 1. LOAD REQUIRED MODULES
# =========================================================
LoadModule proxy_module modules/mod_proxy.so
LoadModule proxy_http_module modules/mod_proxy_http.so
LoadModule headers_module modules/mod_headers.so
LoadModule rewrite_module modules/mod_rewrite.so
LoadModule env_module modules/mod_env.so
LoadModule auth_openidc_module modules/mod_auth_openidc.so
LoadModule wsgi_module modules/mod_wsgi_python3.so

# =========================================================
# 2. WSGI CONFIGURATION 
# =========================================================
WSGIPassAuthorization On
WSGIDaemonProcess api user=apache group=apache threads=5 python-home=/usr/bin/python3
WSGIScriptAlias / /var/www/html/api.py

<Directory /var/www/html>
    WSGIProcessGroup api
    WSGIApplicationGroup %{GLOBAL}
    Require all granted
</Directory>

# =========================================================
# 3. ENVIRONMENT VARIABLES AND HEADERS
# =========================================================
# Extract MODEL_NAME from headers set by the middleware
SetEnvIf X-Original-Model "(.+)" MODEL_NAME=$1
PassEnv MODEL_NAME

# Debug headers for troubleshooting
<IfModule headers_module>
    Header always set X-Debug-Model-Name "%{MODEL_NAME}e" env=MODEL_NAME
    Header always set X-Debug-Proxy-Status "%{HTTP:X-Proxy-To-Backend}e" env=HTTP_X_PROXY_TO_BACKEND
</IfModule>

# Important settings for streaming
RequestHeader unset Accept-Encoding
ProxyPreserveHost On
SetEnv proxy-initial-not-pooled 1
SetEnv force-proxy-request-1.0 1
SetEnv proxy-nokeepalive 1

# =========================================================
# 4. PINGFEDERATE SSO CONFIGURATION
# =========================================================
OIDCProviderMetadataURL https://pingfederate.yourbank.com/.well-known/openid-configuration
OIDCClientID your_client_id
OIDCClientSecret your_client_secret
OIDCRedirectURI https://api.example.com/auth
OIDCCryptoPassphrase some-random-secure-passphrase
OIDCSessionInactivityTimeout 3600
OIDCSessionMaxDuration 28800

# SSO settings
OIDCScope "openid email profile"
OIDCRemoteUserClaim sub
OIDCResponseType "id_token token"
OIDCSSLValidateServer On
OIDCPassIDTokenAs claims
OIDCPassClaimsAs environment
OIDCPassRefreshToken On

# =========================================================
# 5. LOCATION HANDLERS
# =========================================================
# Auth endpoint for SSO callback
<Location "/auth">
    AuthType openid-connect
    Require valid-user
    # After authentication, redirect to token page
    RewriteEngine On
    RewriteRule ^/auth$ /token.html [R,L]
</Location>

# Redirect browser requests to the root URL to token.html
<Location "/">
    # Only apply to GET requests from browsers
    <If "%{REQUEST_METHOD} == 'GET' && %{HTTP_USER_AGENT} =~ /Mozilla|Chrome|Safari|Edge|Firefox/">
        # Redirect to token.html
        RewriteEngine On
        RewriteRule ^/$ /token.html [R,L]
    </If>
</Location>

# Token page - serve directly from filesystem
<Location "/token.html">
    # Use local token.html file
    ProxyPass !
    RewriteEngine On
    RewriteRule ^/token\.html$ /var/www/html/token.html [L]
</Location>

# Public endpoints that don't require authentication
<LocationMatch "^/(token\.html|health)$">
    # Explicitly allow access without authentication
    AuthType None
    Require all granted
    ProxyPreserveHost On
</LocationMatch>

# Test endpoint - bypass JWT validation
<Location "/test">
    # Set test mode header
    RequestHeader set X-Test-Mode "true"
</Location>

# =========================================================
# 6. ERROR RESPONSES
# =========================================================
# Standard OpenAI-compatible error responses
ErrorDocument 400 '{"error": {"message": "Bad request format", "type": "invalid_request_error", "param": null, "code": null}}'
ErrorDocument 401 '{"error": {"message": "Authentication required", "type": "authentication_error", "param": null, "code": null}}'
ErrorDocument 404 '{"error": {"message": "The requested resource was not found", "type": "invalid_request_error", "param": null, "code": null}}'
ErrorDocument 500 '{"error": {"message": "The server had an error processing your request", "type": "server_error", "param": null, "code": null}}'

# =========================================================
# 7. LOGGING CONFIGURATION
# =========================================================
LogLevel warn
# Uncomment for detailed debugging
# LogLevel debug rewrite:trace5

routing.conf

# Model routing configuration - managed via ConfigMap
# This file contains only the routing rules for different models

# Routing rules - only proceed if authentication passed and proxy flag is set
<IfModule rewrite_module>
    RewriteEngine On
    
    # Only proxy requests that have been authenticated and marked for proxying
    RewriteCond %{HTTP:X-Proxy-To-Backend} =true
    
    # Chat Completion Models
    RewriteCond %{ENV:MODEL_NAME} llama-70b [NC]
    RewriteRule ^/(.*)$ http://triton-1.app.svc.cluster.local:9000/v1/chat/completions [P,L]
    
    RewriteCond %{ENV:MODEL_NAME} mixtral [NC]
    RewriteRule ^/(.*)$ http://triton-3.app.svc.cluster.local:9000/v1/chat/completions [P,L]
    
    RewriteCond %{ENV:MODEL_NAME} mistral [NC]
    RewriteRule ^/(.*)$ http://triton-5.app.svc.cluster.local:9000/v1/chat/completions [P,L]
    
    # Embedding Models
    RewriteCond %{ENV:MODEL_NAME} jina [NC]
    RewriteRule ^/(.*)$ http://triton-2.app.svc.cluster.local:8000/v2/models/jina_embedding/generate [P,L]
    
    RewriteCond %{ENV:MODEL_NAME} e5-mistral [NC]
    RewriteRule ^/(.*)$ http://triton-4.app.svc.cluster.local:8000/v2/models/e5_mistral_embedding/generate [P,L]
    
    # Default routing if no model matched but MODEL_NAME is set
    RewriteCond %{ENV:MODEL_NAME} .+
    RewriteRule ^/(.*)$ http://triton-1.app.svc.cluster.local:9000/v1/chat/completions [P,L]
</IfModule>

# Backend server definitions
ProxyPassReverse / http://triton-1.app.svc.cluster.local:9000/
ProxyPassReverse / http://triton-2.app.svc.cluster.local:8000/
ProxyPassReverse / http://triton-3.app.svc.cluster.local:9000/
ProxyPassReverse / http://triton-4.app.svc.cluster.local:8000/
ProxyPassReverse / http://triton-5.app.svc.cluster.local:9000/
ProxyPassReverse / http://triton-6.app.svc.cluster.local:8000/

api.py

import os
import json
import logging
import requests
from jwt import decode as jwt_decode, get_unverified_header, InvalidTokenError
from io import BytesIO

# Configure logging with rotation
from logging.handlers import RotatingFileHandler
handler = RotatingFileHandler(
    os.getenv('LOG_FILE', '/var/log/api.log'),
    maxBytes=10*1024*1024,
    backupCount=5
)
logging.basicConfig(handlers=[handler], level=logging.INFO)

# Configuration
JWKS_URL = os.getenv('JWKS_URL', 'https://pingfederate.yourbank.com/.well-known/jwks.json')
AUDIENCE = os.getenv('AUDIENCE', 'your_client_id')
ISSUER = os.getenv('ISSUER', 'https://pingfederate.yourbank.com')
AUTH_CALLBACK_URL = os.getenv('AUTH_CALLBACK_URL', '/auth')

def validate_jwt(token):
    """Validate JWT using PingFederate's JWKS endpoint."""
    try:
        jwks = requests.get(JWKS_URL, timeout=5, verify=True).json()
        header = get_unverified_header(token)
        kid = header['kid']
        key = next(k for k in jwks['keys'] if k['kid'] == kid)
        decoded = jwt_decode(
            token,
            key,
            algorithms=['RS256'],
            audience=AUDIENCE,
            issuer=ISSUER
        )
        return decoded
    except (requests.RequestException, InvalidTokenError, KeyError, StopIteration) as e:
        logging.error(f"JWT validation failed: {str(e)}")
        return None

def error_response(message, status, headers, start_response):
    """Return a standardized error response."""
    logging.error(message)
    start_response(status, headers)
    return [json.dumps({
        "error": {
            "message": message,
            "type": "invalid_request_error",
            "param": None,
            "code": None
        }
    }).encode('utf-8')]

def check_browser_request(environ):
    """Check if the request is coming from a browser."""
    user_agent = environ.get('HTTP_USER_AGENT', '')
    accept = environ.get('HTTP_ACCEPT', '')
    
    is_browser = (
        ('Mozilla' in user_agent or 'Chrome' in user_agent or 
         'Safari' in user_agent or 'Firefox' in user_agent or 'Edge' in user_agent) and
        ('text/html' in accept)
    )
    
    return is_browser

def application(environ, start_response):
    """WSGI application for JWT validation and model routing."""
    path_info = environ.get('PATH_INFO', '')
    request_method = environ.get('REQUEST_METHOD', '')
    logging.info(f"Processing request: {request_method} {path_info}")
    
    # Handle root URL for browser requests
    if path_info == '/' and request_method == 'GET' and check_browser_request(environ):
        logging.info("Browser request to root URL, redirecting to token.html")
        start_response('302 Found', [('Location', '/token.html')])
        return [b'']
    
    # Skip authentication for token page and other public endpoints
    if path_info.startswith('/token.html') or path_info == '/health':
        logging.info(f"Public endpoint: {path_info}, skipping auth")
        # Immediately return empty response, let Apache handle it
        start_response('200 OK', [
            ('Content-Type', 'application/json'),
            ('X-Public-Endpoint', 'true')
        ])
        return [b'']
    
    # Handle API versions in path (/v1/completions, /v1/chat/completions, etc.)
    if path_info.startswith('/v1/'):
        logging.info(f"API versioned endpoint: {path_info}")
        # These are treated the same as root API calls
    
    # Handle test endpoint - skips JWT validation
    if path_info == '/test' or path_info.startswith('/v1/test') or environ.get('HTTP_X_TEST_MODE') == 'true':
        logging.info("Test endpoint detected - bypassing authentication")
        
        # Parse the request body to extract model name
        try:
            content_length = int(environ.get('CONTENT_LENGTH', 0))
            request_body = environ['wsgi.input'].read(content_length)
            environ['wsgi.input'] = BytesIO(request_body)  # Make body available for reuse
            
            data = json.loads(request_body.decode('utf-8')) if request_body else {}
            model_name = data.get('model')
            
            if not model_name:
                return error_response("Missing model field", '400 Bad Request', 
                                    [('Content-Type', 'application/json')], start_response)
            
            # Set MODEL_NAME for Apache routing
            os.environ['MODEL_NAME'] = model_name
            
            # Return with special headers for test mode
            start_response('200 OK', [
                ('Content-Type', 'application/json'),
                ('X-Original-Model', model_name),
                ('X-Test-Mode', 'true'),
                ('X-Proxy-To-Backend', 'true')
            ])
            return [b'']
            
        except (ValueError, json.JSONDecodeError) as e:
            return error_response(f"Invalid JSON: {str(e)}", '400 Bad Request', 
                                [('Content-Type', 'application/json')], start_response)
    
    # Regular request - validate JWT
    headers = [('Content-Type', 'application/json')]
    jwt_token = None
    
    # Check for JWT token in headers
    for key, value in environ.items():
        if key.startswith('HTTP_') and key[5:].lower() == 'x_jwt_token':
            jwt_token = value
            break
    
    # Check Authorization header with Bearer token
    if not jwt_token and 'HTTP_AUTHORIZATION' in environ:
        auth = environ['HTTP_AUTHORIZATION']
        if auth.startswith('Bearer '):
            jwt_token = auth[7:]  # Remove 'Bearer ' prefix
    
    # If no valid token, return 401
    if not jwt_token or not validate_jwt(jwt_token):
        if not jwt_token:
            logging.error("Missing JWT token")
        else:
            logging.error("Invalid JWT token")
            
        # Return 401 with JSON error
        start_response('401 Unauthorized', headers)
        return [json.dumps({
            "error": {
                "message": "Authentication required. Please provide a valid JWT token.",
                "type": "authentication_error"
            }
        }).encode('utf-8')]
    
    # Parse JSON to extract model name
    try:
        content_length = int(environ.get('CONTENT_LENGTH', 0))
        request_body = environ['wsgi.input'].read(content_length)
        environ['wsgi.input'] = BytesIO(request_body)  # Make body available for reuse
        
        data = json.loads(request_body.decode('utf-8')) if request_body else {}
        
        # Extract model name
        model_name = data.get('model')
        if not model_name:
            return error_response("Missing model field", '400 Bad Request', headers, start_response)
        
        # Set MODEL_NAME for Apache routing
        os.environ['MODEL_NAME'] = model_name
        
        # Start response with headers for Apache routing
        start_response('200 OK', [
            ('Content-Type', 'application/json'),
            ('X-Original-Model', model_name),
            ('X-Proxy-To-Backend', 'true')
        ])
        
        logging.info(f"Auth successful, model: {model_name}, path: {path_info}")
        return [b'']  # Empty response - Apache will proxy the request
        
    except (ValueError, json.JSONDecodeError) as e:
        return error_response(f"Invalid JSON: {str(e)}", '400 Bad Request', headers, start_response)



# =========================================================
# 8. INCLUDE ROUTING CONFIGURATION (from ConfigMap)
# =========================================================
Include conf.d/routing.conf
