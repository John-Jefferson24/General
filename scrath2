api.py > /var/www/html/api.py

import os
import json
import logging
from wsgiref.headers import Headers
import jwt
import requests

# Configure logging
logging.basicConfig(filename='/var/log/api.log', level=logging.INFO)

def validate_jwt(token, jwks_url="https://pingfederate.yourbank.com/.well-known/jwks.json"):
    """Validate JWT using PingFederate's JWKS endpoint."""
    try:
        jwks = requests.get(jwks_url, timeout=5).json()
        header = jwt.get_unverified_header(token)
        kid = header['kid']
        key = next(k for k in jwks['keys'] if k['kid'] == kid)
        decoded = jwt.decode(
            token,
            key,
            algorithms=['RS256'],
            audience='your_client_id',
            issuer='https://pingfederate.yourbank.com'
        )
        return decoded
    except Exception as e:
        logging.error(f"JWT validation failed: {str(e)}")
        return None

def application(environ, start_response):
    """WSGI application for JSON processing and backend forwarding."""
    headers = Headers()
    headers.add('Content-Type', 'application/json')

    # Check for valid JWT
    jwt_token = environ.get('HTTP_X_JWT_TOKEN', '')
    if not jwt_token or not validate_jwt(jwt_token):
        headers.add('Location', '/jwt-callback')
        start_response('302 Found', headers.items())
        return [b'']

    # Ensure POST request
    if environ.get('REQUEST_METHOD') != 'POST':
        logging.error("Non-POST request received")
        start_response('405 Method Not Allowed', headers.items())
        return [json.dumps({
            "error": {
                "message": "Method not allowed",
                "type": "invalid_request_error",
                "param": null,
                "code": null
            }
        }).encode('utf-8')]

    # Read JSON payload (pass-through to backend)
    try:
        length = int(environ.get('CONTENT_LENGTH', 0))
        body = environ['wsgi.input'].read(length).decode('utf-8')
        data = json.loads(body) if body else {}
    except (ValueError, json.JSONDecodeError):
        logging.error("Invalid JSON payload")
        start_response('400 Bad Request', headers.items())
        return [json.dumps({
            "error": {
                "message": "Invalid JSON",
                "type": "invalid_request_error",
                "param": null,
                "code": null
            }
        }).encode('utf-8')]

    # Extract model name (supports nested config)
    model_name = data.get('model', data.get('config', {}).get('model', ''))
    if not model_name:
        logging.error("Missing model field")
        start_response('400 Bad Request', headers.items())
        return [json.dumps({
            "error": {
                "message": "Missing model field",
                "type": "invalid_request_error",
                "param": null,
                "code": null
            }
        }).encode('utf-8')]

    # Set MODEL_NAME environment variable
    os.environ['MODEL_NAME'] = model_name
    logging.info(f"Processed model: {model_name}")

    # Pass-through JSON unchanged (Apache handles proxying)
    start_response('200 OK', headers.items())
    return [json.dumps({
        "status": "Request processed",
        "model": model_name,
        "message": "Forwarding to backend via Apache proxy"
    }).encode('utf-8')]


token.html > Container Path: /var/www/html/token.html

requirements.txt

pyjwt==2.9.0
requests==2.32.3

httpd.conf > /etc/httpd/conf.d/httpd.conf
LoadModule wsgi_modfule modules/mod_wsgi_python3.so

# WSGI configuration for Python script
WSGIDaemonProcess api user=apache group=apache threads=5 python-home=/usr/bin/python3
WSGIScriptAlias / /var/www/html/api.py
<Directory /var/www/html>
    WSGIProcessGroup api
    WSGIApplicationGroup %{GLOBAL}
    Require all granted
</Directory>

# Token display endpoint
<Location /get-token>
    AuthType openid-connect
    Require valid-user
    SetHandler type-map
    ErrorDocument 200 /var/www/html/token.html
</Location>

# Health check endpoint (restricted to OpenShift internal IPs)
<Location /health>
    Require ip 127.0.0.1 10.0.0.0/8 172.30.0.0/16
    SetHandler server-status
</Location>

# Apply SSO to root path for POST requests
<LocationMatch "^/$">
    AuthType openid-connect
    Require valid-user
    ProxyPreserveHost On
    RequestHeader set X-User-ID "%{REMOTE_USER}e"
    RequestHeader set X-JWT-Token "%{OIDC_id_token}e"
    RequestHeader set X-Original-Model "%{ENV:MODEL_NAME}e"
</LocationMatch>

# Error responses in OpenAI format
ErrorDocument 400 '{"error": {"message": "Bad request format", "type": "invalid_request_error", "param": null, "code": null}}'
ErrorDocument 401 '{"error": {"message": "Authentication required", "type": "authentication_error", "param": null, "code": null}}'
ErrorDocument 404 '{"error": {"message": "The requested resource was not found", "type": "invalid_request_error", "param": null, "code": null}}'
ErrorDocument 500 '{"error": {"message": "The server had an error processing your request", "type": "server_error", "param": null, "code": null}}'

security.conf > /etc/httpd/conf.d/security.conf

# Load mod_security module
LoadModule security2_module modules/mod_security2.so

# Enable mod_security
<IfModule security2_module>
    SecRuleEngine On
    SecRequestBodyAccess On
    SecRequestBodyLimit 1048576
    SecRequestBodyNoFilesLimit 1048576
    SecAuditEngine RelevantOnly

    # Validate JSON format for POST requests
    SecRule REQUEST_METHOD "^POST$" \
        "id:1001,\
        phase:2,\
        log,\
        pass,\
        chain"
    SecRule REQUEST_HEADERS:Content-Type "application/json" \
        "chain"
    SecRule REQUEST_BODY "!@rx \"(messages|input)\"" \
        "deny,\
        status:400,\
        log,\
        msg:'Missing required fields (messages or input)'"

    # Sanitize JSON input
    SecRule REQUEST_BODY "@rx [;<>\|]" \
        "id:1002,\
        phase:2,\
        deny,\
        status:400,\
        log,\
        msg:'Invalid characters in JSON payload'"
</IfModule>

sso.conf > /etc/httpd/conf.d/sso.conf

# Load mod_auth_openidc module
LoadModule auth_openidc_module modules/mod_auth_openidc.so

# PingFederate SSO configuration
OIDCProviderMetadataURL https://pingfederate.yourbank.com/.well-known/openid-configuration
OIDCClientID your_client_id
OIDCClientSecret your_client_secret
OIDCRedirectURI https://api.bank.com/jwt-callback
OIDCCryptoPassphrase some-random-secure-passphrase
OIDCSessionInactivityTimeout 3600
OIDCSessionMaxDuration 28800
OIDCScope "openid email profile"
OIDCRemoteUserClaim sub
OIDCResponseType "id_token token"
OIDCSSLValidateServer On
OIDCPassIDTokenAs claims
OIDCPassClaimsAs environment
OIDCPassRefreshToken On

dockerfile

FROM registry.access.redhat.com/ubi8/httpd-24

# Install dependencies
RUN yum install -y python3 python3-pip mod_security mod_wsgi && \
    yum clean all

# Install mod_auth_openidc
RUN yum install -y mod_auth_openidc && \
    yum clean all

# Copy application files
COPY api.py /var/www/html/api.py
COPY token.html /var/www/html/token.html
COPY requirements.txt /tmp/requirements.txt

# Install Python dependencies
RUN pip3 install --no-cache-dir -r /tmp/requirements.txt

# Copy Apache configurations
COPY httpd.conf /etc/httpd/conf/httpd.conf
COPY security.conf /etc/httpd/conf.d/security.conf
COPY sso.conf /etc/httpd/conf.d/sso.conf

# Ensure permissions
RUN chown -R apache:apache /var/www/html /var/log/httpd /var/log/modsecurity && \
    chmod -R 755 /var/www/html /var/log/httpd /var/log/modsecurity

# Expose port
EXPOSE 8080

# Run Apache
CMD ["/usr/sbin/httpd", "-D", "FOREGROUND"]



apiVersion: v1
kind: ConfigMap
metadata:
  name: apache-routing-config
  namespace: your-namespace
data:
  routing.conf: |
    # Load required modules
    LoadModule proxy_module modules/mod_proxy.so
    LoadModule proxy_http_module modules/mod_proxy_http.so
    LoadModule headers_module modules/mod_headers.so
    LoadModule rewrite_module modules/mod_rewrite.so

    # Routing rules based on MODEL_NAME
    <IfModule rewrite_module>
        # Chat Completion Models (OpenAI-compatible /v1/chat/completions)
        RewriteCond %{ENV:MODEL_NAME} llama-70b
        RewriteRule ^/(.*)$ http://triton-1.app.svc.cluster.local:9000/v1/chat/completions [P,L,NE]
        RewriteRule ^/(.*)$ - [E=ENDPOINT_TYPE:chat]

        RewriteCond %{ENV:MODEL_NAME} mixtral
        RewriteRule ^/(.*)$ http://triton-1.app.svc.cluster.local:9000/v1/chat/completions [P,L,NE]
        RewriteRule ^/(.*)$ - [E=ENDPOINT_TYPE:chat]

        RewriteCond %{ENV:MODEL_NAME} mistral
        RewriteRule ^/(.*)$ http://triton-1.app.svc.cluster.local:9000/v1/chat/completions [P,L,NE]
        RewriteRule ^/(.*)$ - [E=ENDPOINT_TYPE:chat]

        # Embedding Models (Triton PyTorch /v2/models/X/generate)
        RewriteCond %{ENV:MODEL_NAME} jina
        RewriteRule ^/(.*)$ http://triton-2.apps.svc.cluster.local:8000/v2/models/jina_embedding/generate [P,L,NE]
        RewriteRule ^/(.*)$ - [E=ENDPOINT_TYPE:embedding]

        RewriteCond %{ENV:MODEL_NAME} e5-mistral
        RewriteRule ^/(.*)$ http://triton-2.apps.svc.cluster.local:8000/v2/models/e5_mistral_embedding/generate [P,L,NE]
        RewriteRule ^/(.*)$ - [E=ENDPOINT_TYPE:embedding]

        # Default routing (assume chat completion)
        RewriteCond %{ENV:MODEL_NAME} ^$
        RewriteRule ^/(.*)$ http://triton-1.app.svc.cluster.local:9000/v1/chat/completions [P,L,NE]
        RewriteRule ^/(.*)$ - [E=ENDPOINT_TYPE:chat]
    </IfModule>

    # Proxy settings for streaming
    SetEnv proxy-initial-not-pooled 1
    SetEnv force-proxy-request-1.0 1
    SetEnv proxy-nokeepalive 1
