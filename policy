# Complete Orchestra Labs Network Policy Implementation Guide

## Table of Contents
1. [Orchestra Labs Network Policy Standards](#orchestra-labs-network-policy-standards)
2. [Your Specific Implementation](#your-specific-implementation)
3. [Complete Configuration Examples](#complete-configuration-examples)
4. [Testing & Verification](#testing--verification)
5. [Troubleshooting](#troubleshooting)

---

# Orchestra Labs Network Policy Standards and Documentation

## Overview
These network policies should be applied to:
- All instances of Jupyter Lab
- Any container that will need to be isolated from communicating with outside resources within Orchestra Labs

## Network Policies
There are three policies that need to be applied to any instance of Jupyter Labs when we onboard and setup a new project. These will need to be applied within the jupyter_cd repo, in the Deployment Config manifest (dc.yaml).

## Rarely Changed Policies

### 1. restricted-allow-dns-networkpolicy
This policy is designed to allow access to only ports that are used for DNS within OpenShift. If any pod has the label `restricted: "true"`, then:
- That pod will have access egress (outbound) network connections restricted by default
- That pod will be allowed to communicate on ports 53 and 5353 via TCP and UDP

```yaml
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: restricted-allow-dns-networkpolicy
  namespace: ${PROJ}
spec:
  podSelector:
    matchLabels:
      restricted: "true"
  egress:
    - ports:
        - protocol: UDP
          port: 53
        - protocol: TCP
          port: 53
        - protocol: UDP
          port: 5353
        - protocol: TCP
          port: 5353
  policyTypes:
    - Egress
```

### 2. restricted-fedsso-networkpolicy
This policy is designed to allow communication with FedSSO DEV in OpenShift. If any pod has the label `restricted: "true"`, then:
- That pod will have access egress (outbound) network connections restricted by default
- That pod will be able to communicate outbound with any IP address in the block range used by FedSSO
- EXTERNAL_FEDSSO_IP and INTERNAL_FEDSSO_IP will be defined in the CD repository. If for some reason these change, then we should be in a position to redefine them relatively quickly.

```yaml
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: restricted-fedsso-networkpolicy
  namespace: ${PROJ}
spec:
  podSelector:
    matchLabels:
      restricted: "true"
  egress:
    - to:
        - ipBlock:
            cidr: ${EXTERNAL_FEDSSO_IP}/32
    - to:
        - ipBlock:
            cidr: ${INTERNAL_FEDSSO_IP}/32
  policyTypes:
    - Egress
```

## Commonly Amended Policies

### 3. <project abbreviation>-internal-only-networkpolicy
One instance of this policy should be applied for each instance of Jupyter Lab we set up. If this pod has the label `<project abbreviation>: "restricted"`:
- That pod will have access egress (outbound) network connections restricted by default
- Any communication with another pod will allow that pod to communicate with any other pod that has the label `<project abbreviation>: "resource"`
- Note that `<project abbreviation>` should be substituted in the template with an explicit value

```yaml
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: ${PROJECT_ABBREV}-internal-only-networkpolicy
  namespace: ${PROJ}
spec:
  podSelector:
    matchLabels:
      ${PROJECT_ABBREV}: "restricted"
  egress:
    - to:
        - podSelector:
            matchLabels:
              ${PROJECT_ABBREV}: "resource"
  policyTypes:
    - Egress
```

### 4. <project abbreviation>-<resource name>-custom-resource-only-networkpolicy
This should be rarely used when a pod needs access to a custom resource outside of OpenShift. If this pod has the label `<project abbreviation>: "restricted"`:
- That pod will have access egress (outbound) network connections restricted by default
- The pod will be allowed to communicate with the IP addresses listed

```yaml
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: ${PROJECT_ABBREV}-${RESOURCE_NAME}-custom-resource-only-networkpolicy
  namespace: ${PROJ}
spec:
  podSelector:
    matchLabels:
      ${PROJECT_ABBREV}: "restricted"
  egress:
    - to:
        - ipBlock:
            cidr: ${CUSTOM_RESOURCE_IP}/32
  policyTypes:
    - Egress
```

## Labels

The following labels will be used to define resource access:

- **`${PROJECT_ABBREV}: "restricted"`** - Applied to Jupyter Lab pods. These pods are restricted and can only communicate with project resources and essential services (DNS, FedSSO, custom resources if needed).

- **`${PROJECT_ABBREV}: "resource"`** - Applied to internal project resources (APIs, databases, services) that Jupyter Lab instances need to access.

- **`restricted: "true"`** - Applied to Jupyter Lab pods to enable DNS and FedSSO access policies. This works in combination with the project-specific label.

**Label Application Strategy:**
- Jupyter Lab pods get **BOTH** labels: `restricted: "true"` AND `${PROJECT_ABBREV}: "restricted"`
- Internal project resources get: `${PROJECT_ABBREV}: "resource"`
- External/custom resources are accessed via IP-based policies (no labels required)

## Scenario Analysis: How The Policies Work Together

### Example Project Setup
Let's trace through a real scenario with project "ALPHA":

**Components:**
- Jupyter Lab pod: `alpha-jupyter-pod`
- Internal API pod: `alpha-model-api-pod`  
- External Redis service at: `10.50.100.25`
- DNS servers at: `8.8.8.8:53`
- FedSSO at: `192.168.1.100`

### Pod Labels Applied
```yaml
# Jupyter Lab Pod
labels:
  restricted: "true"          # Enables DNS + FedSSO policies
  alpha: "restricted"         # Enables internal + custom resource policies

# Internal API Pod  
labels:
  alpha: "resource"          # Makes it accessible to Jupyter pods
```

### Policy Evaluation Flow

When `alpha-jupyter-pod` tries to communicate, OpenShift evaluates **ALL** matching NetworkPolicies additively:

#### ✅ **Allowed Traffic:**

1. **DNS Queries** (Port 53/5353 TCP/UDP)
   - Matched by: `restricted-allow-dns-networkpolicy`
   - Selector: `restricted: "true"` ✓
   - Result: Can reach DNS servers

2. **FedSSO Authentication** (192.168.1.100)
   - Matched by: `restricted-fedsso-networkpolicy` 
   - Selector: `restricted: "true"` ✓
   - Result: Can authenticate with FedSSO

3. **Internal API Communication** (alpha-model-api-pod)
   - Matched by: `alpha-internal-only-networkpolicy`
   - Selector: `alpha: "restricted"` ✓
   - Target: pods with `alpha: "resource"` ✓
   - Result: Can communicate with internal APIs

4. **Custom External Resource** (10.50.100.25 - Redis)
   - Matched by: `alpha-redis-custom-resource-only-networkpolicy`
   - Selector: `alpha: "restricted"` ✓
   - Target: `10.50.100.25/32` ✓
   - Result: Can reach external Redis

#### ❌ **Blocked Traffic:**

1. **Random Internet Access** (e.g., google.com)
   - No policy allows general internet egress
   - Result: **BLOCKED**

2. **Other Project Resources** (beta-api-pod)
   - No policy allows cross-project communication
   - Result: **BLOCKED**

3. **Unauthorized External IPs** (10.20.30.40)
   - Not in any allowed IP blocks
   - Result: **BLOCKED**

### Network Flow Summary

```
alpha-jupyter-pod CAN reach:
├── DNS servers (8.8.8.8:53) ← restricted-allow-dns-networkpolicy
├── FedSSO (192.168.1.100) ← restricted-fedsso-networkpolicy  
├── alpha-model-api-pod ← alpha-internal-only-networkpolicy
└── Redis (10.50.100.25) ← alpha-redis-custom-resource-only-networkpolicy

alpha-jupyter-pod CANNOT reach:
├── General internet ← No matching policy
├── Other projects ← No matching policy
└── Unlisted IPs ← No matching policy
```

### Key Insights

1. **Additive Security**: Multiple policies combine to create comprehensive but restrictive access
2. **Default Deny**: Anything not explicitly allowed is blocked
3. **Label-Based**: Policies use label selectors for flexible, maintainable rules
4. **Layered Approach**: Basic services (DNS/Auth) + Project resources + Custom needs

---

# Your Specific Implementation

## Your Infrastructure Overview

```
Project A Namespace:
├── JupyterHub Pod A
├── PyPI Server A + Service + Route  
└── Internal API Pods (various ports)

Project B Namespace:
├── JupyterHub Pod B
├── PyPI Server B + Service + Route
└── Internal API Pods (various ports)

Project C Namespace:  
├── JupyterHub Pod C
├── PyPI Server C + Service + Route
└── Internal API Pods (various ports)

External Resources:
└── Redis Server (external IP:10000)
```

## Step 1: Pod Labels Configuration

### JupyterHub Pods (All 3 Projects)
Apply these labels to each JupyterHub pod (following Orchestra Labs wiki):

```yaml
# Project A JupyterHub Pod
metadata:
  labels:
    restricted: "true"          # Enables DNS + FedSSO policies
    projecta: "restricted"      # Marks as restricted pod for project A
    
# Project B JupyterHub Pod  
metadata:
  labels:
    restricted: "true"          # Enables DNS + FedSSO policies
    projectb: "restricted"      # Marks as restricted pod for project B
    
# Project C JupyterHub Pod
metadata:
  labels:
    restricted: "true"          # Enables DNS + FedSSO policies  
    projectc: "restricted"      # Marks as restricted pod for project C
```

### PyPI Server Pods (All 3 Projects)
```yaml
# Project A PyPI Server
metadata:
  labels:
    projecta: "resource"        # Accessible by Project A Jupyter

# Project B PyPI Server
metadata:
  labels:
    projectb: "resource"        # Accessible by Project B Jupyter
    
# Project C PyPI Server  
metadata:
  labels:
    projectc: "resource"        # Accessible by Project C Jupyter
```

### Internal API Pods (All 3 Projects)
```yaml
# Project A API Pods
metadata:
  labels:
    projecta: "resource"        # Accessible by Project A Jupyter

# Project B API Pods  
metadata:
  labels:
    projectb: "resource"        # Accessible by Project B Jupyter
    
# Project C API Pods
metadata:
  labels:  
    projectc: "resource"        # Accessible by Project C Jupyter
```

---

# Complete Configuration Examples

## Step 2: NetworkPolicy Deployment

### Deploy These 4 Policies Per Project (12 total policies)

#### Project A NetworkPolicies:

**1. DNS Access (shared)**
```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: restricted-allow-dns-networkpolicy
  namespace: project-a-namespace
spec:
  podSelector:
    matchLabels:
      restricted: "true"
  egress:
    - ports:
        - protocol: UDP
          port: 53
        - protocol: TCP  
          port: 53
        - protocol: UDP
          port: 5353
        - protocol: TCP
          port: 5353
  policyTypes:
    - Egress
```

**2. FedSSO Access (shared)**
```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: restricted-fedsso-networkpolicy
  namespace: project-a-namespace
spec:
  podSelector:
    matchLabels:
      restricted: "true"
  egress:
    - to:
        - ipBlock:
            cidr: 192.168.1.100/32  # Replace with actual FedSSO IP
    - to:
        - ipBlock:
            cidr: 192.168.1.101/32  # Replace with actual internal FedSSO IP
  policyTypes:
    - Egress
```

**3. Internal Project Resources**
```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: projecta-internal-only-networkpolicy
  namespace: project-a-namespace
spec:
  podSelector:
    matchLabels:
      projecta: "restricted"    # Selects JupyterHub pods
  egress:
    - to:
        - podSelector:
            matchLabels:
              projecta: "resource"  # Targets PyPI + API pods
  policyTypes:
    - Egress
```

**4. External Redis Access**
```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: projecta-redis-custom-resource-networkpolicy
  namespace: project-a-namespace
spec:
  podSelector:
    matchLabels:
      projecta: "restricted"    # Selects JupyterHub pods
  egress:
    - to:
        - ipBlock:
            cidr: YOUR_REDIS_IP/32  # Replace with actual Redis IP
      ports:
        - protocol: TCP
          port: 10000
  policyTypes:
    - Egress
```

#### Project B NetworkPolicies:
```yaml
# Repeat above 4 policies with:
# - namespace: project-b-namespace  
# - projecta: "restricted" -> projectb: "restricted" in selectors
# - projecta: "resource" -> projectb: "resource" in targets
# - Same Redis IP and port 10000
```

#### Project C NetworkPolicies:
```yaml  
# Repeat above 4 policies with:
# - namespace: project-c-namespace
# - projecta: "restricted" -> projectc: "restricted" in selectors  
# - projecta: "resource" -> projectc: "resource" in targets
# - Same Redis IP and port 10000
```

## Step 3: Network Flow Verification

### What Each JupyterHub Can Access:

#### ✅ **Allowed Traffic Per Project:**
```
Project A JupyterHub → 
├── DNS servers (port 53/5353)
├── FedSSO authentication  
├── Project A PyPI server (any port)
├── Project A API pods (any port)
└── External Redis (port 10000)

Project B JupyterHub →
├── DNS servers (port 53/5353)  
├── FedSSO authentication
├── Project B PyPI server (any port)
├── Project B API pods (any port)
└── External Redis (port 10000)

Project C JupyterHub →
├── DNS servers (port 53/5353)
├── FedSSO authentication  
├── Project C PyPI server (any port)
├── Project C API pods (any port)
└── External Redis (port 10000)
```

#### ❌ **Blocked Traffic (Security Features):**
```
✗ Project A cannot reach Project B/C resources
✗ Project B cannot reach Project A/C resources  
✗ Project C cannot reach Project A/B resources
✗ No general internet access
✗ No unauthorized external IPs
✗ No cross-project communication
```

## Step 4: Deployment Parameters

### dc.yaml Parameter Substitution Example:

```yaml
# For Project A
parameters:
  - name: PROJECT_ABBREV
    value: "projecta"
  - name: PROJ
    value: "project-a-namespace"
  - name: EXTERNAL_FEDSSO_IP  
    value: "192.168.1.100"     # Replace with actual
  - name: INTERNAL_FEDSSO_IP
    value: "192.168.1.101"     # Replace with actual  
  - name: REDIS_IP
    value: "10.50.100.25"      # Replace with actual Redis IP

# For Project B - change project references
# For Project C - change project references
```

---

# Testing & Verification

## Step 5: Testing Commands

### From Each JupyterHub Pod:

```bash
# ✅ Test DNS
nslookup google.com

# ✅ Test FedSSO
curl -I https://YOUR_FEDSSO_IP/auth

# ✅ Test PyPI Server (adjust service name)
curl http://projecta-pypi-service:8080/simple/

# ✅ Test Internal APIs (adjust service names/ports)
curl http://projecta-api1-service:3000/health
curl http://projecta-api2-service:8080/status

# ✅ Test Redis  
redis-cli -h YOUR_REDIS_IP -p 10000 ping

# ❌ Should fail - other project (from Project A)
curl http://projectb-pypi-service:8080 --connect-timeout 5

# ❌ Should fail - general internet
curl -I https://google.com --connect-timeout 5
```

## Step 6: Implementation Checklist

### Before Deployment:
- [ ] Replace `YOUR_REDIS_IP` with actual Redis server IP
- [ ] Replace `YOUR_FEDSSO_IP` with actual FedSSO server IPs  
- [ ] Confirm namespace names match your setup
- [ ] Verify service names for PyPI and API services

### After Deployment:
- [ ] Test DNS resolution from each JupyterHub
- [ ] Test PyPI access (pip install should work)
- [ ] Test each internal API service
- [ ] Test Redis connectivity on port 10000
- [ ] Verify cross-project isolation (should fail)
- [ ] Confirm internet access is blocked

---

# Troubleshooting

### Common Issues and Solutions:

#### 1. **Policy Not Working**
```bash
# Check applied policies
kubectl get networkpolicy -n project-a-namespace

# Verify policy details
kubectl describe networkpolicy restricted-allow-dns-networkpolicy -n project-a-namespace
```

#### 2. **Connectivity Issues**
```bash
# Check pod labels  
kubectl get pods -n project-a-namespace --show-labels

# Test specific connectivity
kubectl exec -it jupyterhub-pod -- curl http://service:port

# Check if labels match policy selectors
kubectl get pods -l "restricted=true" -n project-a-namespace
kubectl get pods -l "projecta=restricted" -n project-a-namespace
```

#### 3. **DNS Not Working**
- Verify `restricted: "true"` label on JupyterHub pods
- Check DNS policy is deployed in correct namespace
- Test with: `kubectl exec -it pod -- nslookup kubernetes.default`

#### 4. **Cross-Project Access Issues**
- This should be blocked by design
- If accidentally working, check for missing/incorrect labels
- Ensure policies are deployed in all namespaces

#### 5. **Redis Connection Fails**
- Verify Redis IP and port 10000 in custom resource policy
- Check firewall rules on external Redis server
- Test: `kubectl exec -it pod -- telnet REDIS_IP 10000`

### Debug Commands:
```bash
# View all network policies
kubectl get networkpolicy --all-namespaces

# Check policy YAML
kubectl get networkpolicy POLICY_NAME -o yaml

# View pod network details
kubectl exec -it POD_NAME -- ip route
kubectl exec -it POD_NAME -- netstat -tuln

# Test specific connections with timeout
kubectl exec -it POD_NAME -- curl -v --connect-timeout 10 URL
```

---

## Quick Summary - Your Action Items:

### **1. Label Your Pods (Per Orchestra Labs Wiki):**
**JupyterHub pods** (3 total):
- `restricted: "true"` + `projecta/projectb/projectc: "restricted"`

**PyPI + API pods** (multiple per project):
- `projecta/projectb/projectc: "resource"`

### **2. Deploy NetworkPolicies:**
- **12 policies total** (4 per project)
- Each project gets: DNS + FedSSO + Internal + Redis policies
- Only change: project abbreviation and namespace

### **3. Key Configuration Points:**
- **Redis IP**: Replace `YOUR_REDIS_IP` with actual external Redis IP
- **Redis Port**: Already set to 10000 ✅
- **FedSSO IPs**: Replace with your actual authentication server IPs
- **Namespaces**: Adjust to match your actual namespace names

### **4. What This Achieves:**
✅ Each JupyterHub can reach its own PyPI server and APIs  
✅ All JupyterHubs can reach shared Redis on port 10000  
✅ Complete project isolation (A can't reach B's resources)  
✅ Essential services (DNS, auth) work  
❌ No unauthorized internet or cross-project access  

### **5. Testing:**
From each JupyterHub, test pip install, API calls, and Redis connections. Cross-project calls should fail.

## Key Benefits of This Setup

1. **Project Isolation**: Each project can only access its own resources
2. **Shared Services**: All projects can access Redis and authentication  
3. **Internal APIs**: Full access to project-specific APIs on any port
4. **PyPI Access**: Package installation works within each project
5. **Security**: Default deny with explicit allow rules
6. **Scalable**: Easy to add new projects with same pattern

## Additional Information

⚠️ **Important**: Always be certain to test that your network policies function as expected after implementation.

**Egress Network Policies in OpenShift are additive**; for more information see: [Kubernetes Network Policies Documentation](https://kubernetes.io/docs/concepts/services-networking/network-policies/#the-two-sorts-of-pod-isolation)

## Resources
- Kubernetes Network Policies: https://kubernetes.io/docs/concepts/services-networking/network-policies/#the-two-sorts-of-pod-isolation

## Related Articles
- Orchestra Labs Network Policy Standards and Documentation
